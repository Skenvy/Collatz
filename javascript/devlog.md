# Devlog
"[JavaScript](https://www.ecma-international.org/publications-and-standards/standards/ecma-262/)" is a hard target to pin down precisely what would be the best way to learn it, without first learning the history of the language, as an evolution of ECMA Script; see [ECMAScript Language Specification](https://tc39.es/ecma262/) and [ECMAScript Internationalization API Specification](https://tc39.es/ecma402/) for the _most_ "source of truth" as it gets for JavaScript (even if a cumbersome point of reference to get up and running with a project quickly, they are important to be aware of). As from the start the JavaScript ecosystem was fragmented across various browsers, there is no single source of truth for how a "JavaScript Engine" enacts the ECMAScript language spec, so it's worth knowing of the major engines (with there being a distinction between the [JavaScript Engine](https://en.wikipedia.org/wiki/JavaScript_engine) and the [Browser Engine](https://en.wikipedia.org/wiki/Browser_engine)).
* [ChakraCore](https://github.com/chakra-core/ChakraCore) is an evolution of the Microsoft IE JS Engine, Chakra.
* [JavaScriptCore](https://github.com/WebKit/webkit/blob/main/Source/JavaScriptCore/API/JavaScriptCore.h) (a part of [WebKit](https://webkit.org/)) ([opensource.apple](https://opensource.apple.com/projects/webkit/)) (or on [github](https://github.com/WebKit/WebKit))
    * [Bun](https://bun.sh/) (or on [github](https://github.com/oven-sh/bun)), a new and still experimental runtime which "embeds" JavaScriptCore.
* [SpiderMonkey](https://spidermonkey.dev/) ([firefox-source-docs](https://firefox-source-docs.mozilla.org/js/index.html)) ([mozilla-central/source](https://searchfox.org/mozilla-central/source/js/src)) ([Gecko on github](https://github.com/mozilla/gecko-dev))
* [V8](https://github.com/v8/v8) ([googlesource](https://chromium.googlesource.com/v8/v8.git)) [v8.dev](https://v8.dev/)
    * [Node.JS](https://nodejs.org/), or on [github](https://github.com/nodejs/node), is the most widely used JS Engine, and is built on V8.
    * [Deno](https://deno.land/), or on [github](https://github.com/denoland/deno), is also built on V8, with many more features OotB.

The three "server side runtimes" are Node (V8), Deno (V8), or the recent and experimental Bun (JavaScriptCore). Bun's package management is "npm compatible", so if our goal is to create a JavaScript package, we need to focus on Node and Deno.
* Node packages can be hosted on [npm](https://www.npmjs.com/) (see [Getting started](https://docs.npmjs.com/getting-started)), and are manually `npm publish`'d.
* Deno packages can be seen on [Deno Third Party Modules](https://deno.land/x) (see [Adding a module](https://deno.land/add_module)), and are cached from public GitHub repos.
* We also want to target the [github hosted npm registry](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-npm-registry) (also see [Publishing Node.js packages](https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages)).

---

JavaScript (at least, as it was first created by Brendan Eich in 1995) has gone through a long history of corporate holdouts on standardising its adoption (leading to its early fragmented _sources_ of "truth") until 2009 when all the major implementations conformed, and agreed to adopt a shared standard, from [ECMAScript 5](https://262.ecma-international.org/5.1/) and onwards. The early fragmented nature of JavaScript has lead to subsequent releases of languages that are strict supersets of JavaScript, and transpile to JavaScript. By far the most common of these is Microsoft's [TypeScript](https://www.typescriptlang.org/), which adds static typing amongst other features. Others worth noting are;
* [PureScript](https://www.purescript.org/): Functional programming language.
* [AssemblyScript](https://www.assemblyscript.org/): [TypeScript](https://www.typescriptlang.org/) for [WebAssembly](https://webassembly.org/).
* [CoffeeScript](https://coffeescript.org/).

Although this implementation is supposed to be the "JavaScript" implementation, for reasons discussed much further down, it will more honestly be a "TypeScript" implementation that will be transpiled into two different types of JavaScript, targetting the split in module systems between NodeJS's original CommonJS module system, and the subsequent standardised ECMAScript Modules.

---

At the time of writing this, `npm` already has a [`collatz` package](https://www.npmjs.com/package/collatz) (from [this repo](https://github.com/partkyle/collatz)), and `deno.land/x` has [collatz_wasm](https://deno.land/x/collatz_wasm@0.0.1) (which is [also on npm](https://www.npmjs.com/package/collatz-wasm)) (from [this repo](https://github.com/hexagon6/collatz-wasm)). For github hosted packages, we'll look at [this search](https://github.com/search?q=collatz&type=registrypackages). Oddly enough, at the time of writing this, I was getting ready to say there is no `npm` package with the name `collatz` in the github `npm` registry, as it was not appearing without being logged in, but when I searched again from a browser I was logged in with, [this package](https://github.com/pavan142/collatz/pkgs/npm/collatz) appeared.

A good resource for starting to learn "JavaScript" would be [mozilla's developer docs on JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript) ([or guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide)). Two links recommended by the GitHub "[Working with the npm registry](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-npm-registry)" page include [Creating a package.json file](https://docs.npmjs.com/creating-a-package-json-file) and [Creating Node.js modules](https://docs.npmjs.com/creating-node-js-modules).

---

We'll need to start with [signing up to npm](https://www.npmjs.com/signup). I made [my profile](https://www.npmjs.com/~skenvy). Something that immediately stands out is that the one time password email includes links for [Configuring two-factor authentication](https://docs.npmjs.com/configuring-two-factor-authentication) and [Creating and viewing access tokens](https://docs.npmjs.com/creating-and-viewing-access-tokens), as `2FA` is required for logging in; although an "Automation" token can be made for publishing packages without a 2FA token, it can only be made from the website, not from the CLI. So we'll do that now. There's also an option to "Linked Accounts & Recovery Option" with a GitHub account, which seems worthwhile trying, if it didn't request the egregious permission of "Act on your behalf". Why does it want that permission?

An important concept for npm is [scope](https://docs.npmjs.com/about-scopes), both [public](https://docs.npmjs.com/about-public-packages) and [private](https://docs.npmjs.com/about-private-packages). I hadn't realised before that npm included this feature. But because it is included we can focus on [creating a public **scoped** package](https://docs.npmjs.com/creating-and-publishing-scoped-public-packages), because there already exists an **unscoped** [collatz](https://www.npmjs.com/package/collatz) package on npm. Starting off, our `node --version` is `v17.6.0`, and our `npm -v` is `8.5.5`. We can create the initial [`package.json` file](https://docs.npmjs.com/cli/v8/configuring-npm/package-json) with default values (`--yes`) within a scope (`--scope=@scope-name`) by running `npm init --scope=@skenvy --yes`. Because it'll be initialised with a scope, we'll have to publish it with `npm publish --access=public`, as scoped packages default to private.

The [package license](https://docs.npmjs.com/cli/v8/configuring-npm/package-json#license) should be an [OSI approved](https://opensource.org/licenses/alphabetical) identifier from the [SPDX License List](https://spdx.org/licenses/). Although I'm trying to add as many of the optional data fields in the package json as possible, rather than use [`"files": ["*"],`](https://docs.npmjs.com/cli/v8/configuring-npm/package-json#files) we'll use an [.npmignore](https://docs.npmjs.com/cli/v8/using-npm/developers#testing-whether-your-npmignore-or-files-config-works) file, which can be tested with `npm pack` to generate the tarball locally. Although, to "use" the `.npmignore`, we don't actually need to add one, unless its contents would differ from the `.gitignore` that's already present, as outlined via "If there is a `.gitignore` file, and `.npmignore` is missing, `.gitignore`'s contents will be used instead." As a moment of learning, this being the first time I'm setting up a node package, I find it noteworthy that there is a ["browser" option](https://docs.npmjs.com/cli/v8/configuring-npm/package-json#browser), which is mutually exclusive with ["main"](https://docs.npmjs.com/cli/v8/configuring-npm/package-json#main) as I'd assumed node modules weren't supposed to target the client side! Other note worthy options are `bin` and `man` for packaging scripts that should be symlinked to a bin folder, and for requesting the man docs. Following this we have [a whole guide dedicated to the "scripts" dictionary entry](https://docs.npmjs.com/cli/v8/using-npm/scripts). Following the scripts and config, are several different ways to define dependencies (including `"overrides"` to lock sub-dependencies), there are the `"engines"`, `"os"`, and `"cpu"` options (and the `"private"` and `"publishConfig"` to prevent accidentally pushing/publishing).

Another important concept is the [difference between a "package" and a "module"](https://docs.npmjs.com/about-packages-and-modules). Even though this wont impact how we go about creating a package, it's important to understand why _"almost"_ all packages can be modules but not all modules are packages. Although the page linked to has additional caveat that describe additional ways to procure packages, the central defining factor of a package is "A package is a file or directory that is described by a `package.json` file." We saw above that there are two primary types of packages; those that define a `"main"`, and those that define a `"browser"` option. The "_"almost"_ all packages can be modules" is discluding those that define a `"browser"` option. As for modules; "A module is any file or directory in the `node_modules` directory that can be loaded by the Node.js `require()` function." Things that satisfy this are packages that define a `"main"`, and other javascript files that aren't necessarily stored in packages.

---

This is the point at which we'd follow [Creating Node.js modules](https://docs.npmjs.com/creating-node-js-modules). Although it is a nice anchor to other docs that are adjacent to it, it doesn't do much for recommending a good project setup besides saying "have a `package.json` file with a `"name"` and `"version"`, and to include a `console.log` line in "the file". Whilst at this point I'm aware that "the file" is the `"main"` file, and even though two pages that precede it ([About packages and modules](https://docs.npmjs.com/about-packages-and-modules) and [Creating a package.json file](https://docs.npmjs.com/creating-a-package-json-file)) would include steps that would inform the reader of that, it's surprising that the "example" Node package creation at [Creating Node.js modules](https://docs.npmjs.com/creating-node-js-modules) is not a shade more verbose about that. I can definitely see someone jumping straight to this page and potentially being confused. There really should be a "here's all the things you need for a minimum working package". Even if **technically** all you need for a **minimum _working_ package** is a `"name"` and `"version"` in a `package.json` file, it's a fair assumption that there would be a single page guide for slapping together a `package.json` file **AND** the `index.js` file (or whatever else `"main"` is).

I'd also have figured there'd be a more robust testing example besides what it currently says, which is to **publish the example console log line package to npm**, then swap to another directory and install it, then add a `test.js` file that requires the module and runs it. Even if there isn't a recommended test suite module, that honestly sounds like so large an anti-pattern I'm not convinced it wasn't an off-season April Fools joke. Not solely the use of publishing to test, as there's certainly room to publish an early version to confirm the process, but the part that seems grossly objectionable is that reading only that and not reading further could leave the impression that the order of the process for testing requires a package to be published, before it can then be installed and required and tested. Would the remedy if it then didn't pass that testing phase to yank that version..?

There's a few guides that might be more robut for setting up a good node package. For instance, theres [this snyk blog](https://snyk.io/blog/best-practices-create-modern-npm-package/) ([which addresses this example repo](https://github.com/snyk-labs/modern-npm-package)), a [freecodecamp blog](https://www.freecodecamp.org/news/how-to-make-a-beautiful-tiny-npm-package-and-publish-it-2881d4307f78/) (which is entertaining if not at least for the demonstration of publishing the absolute minimum of a package) (and also links to an interesting aggregating site [packagephobia](https://packagephobia.com/result?p=%40bamblehorse%2Ftiny)), and possibly look at [ESLint](https://eslint.org/docs/latest/user-guide/getting-started) (which may include looking at [Airbnb's .eslintrc](https://www.npmjs.com/package/eslint-config-airbnb), because the [Airbnb JavaScript Style Guide](https://airbnb.io/javascript/) is supposedly noteworthy).

---

Before jumping into [the snyk blog](https://snyk.io/blog/best-practices-create-modern-npm-package/), lets look more at targetting the [github hosted npm registry](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-npm-registry) (and [Publishing Node.js packages](https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages)). While trying to set up the workflows, I initially added the optional caching in the `setup-node` action but ended up getting an error of "Error: Cache folder path is retrieved for npm but doesn't exist on disk: /home/runner/.npm" in the post-step. Issues [#317](https://github.com/actions/setup-node/issues/317) and [#479](https://github.com/actions/setup-node/issues/479) appear to demonstrate that the action is generally hostile to caching.

---

One of the top considerations for starting to learn javascript, with the end goal of its utility by node, is the dichotomy of the two "module formats" that node can be used with. Prior to "[ECMAScript modules](https://nodejs.org/docs/latest/api/esm.html)" being introduced around 2015 as the standard module format that browsers adopted, NodeJS was built around its own module system "[CommonJS modules](https://nodejs.org/docs/latest/api/modules.html)" which was the only module system supported by Node until version 12, where ECMAScript modules were slowly introduced until being fully supported by version 13/14 ([from this reflectoring blog](https://reflectoring.io/nodejs-modules-imports/) and [this logrocket blog](https://blog.logrocket.com/commonjs-vs-es-modules-node-js/)). For a deep dive on the loading order of ECMAScript modules, see [this mozilla "hacks" blogs](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/). To yield a resulting package that can support both "CommonJS modules" (`*.cjs` files) _AND_ "ECMAScript modules" (`*.mjs` files) (with `*.js` files being treated as the module specified in the `package.json`, with CommonJS being default, and ECMAScript being if `"type": "module"` is included). It's worth noting that [V8, the engine Node runs on, recommends ECMAScript modules](https://v8.dev/features/modules#mjs). The approach recommended by [the snyk blog](https://snyk.io/blog/best-practices-create-modern-npm-package/) is to write a TypeScript module, which is then transpiled according to `tsconfig` files and includes a `prepack` script which `tsc` comiles the TypeScript into _BOTH_ `*.cjs` _AND_ `*.mjs` formats.

This means that instead of writing JavaScript for this "JavaScript implementation", we'll be writing TypeScript instead. The first part of setting up a TypeScript build environment for multiple build targets, is taking advantage of the extensible [`tsconfig.json`](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) ([reference](https://www.typescriptlang.org/tsconfig)) [extends](https://www.typescriptlang.org/tsconfig#extends) option, to have a shared config base and diverging config for targetting CommonJS builds and ECMAScript builds. We'll also be replacing the `"main"` field in our `package.json` with an `"exports"` [field](https://nodejs.org/api/packages.html#packages_exports). Although `"exports"` can be an "alternative" to `"main"`, we'll set the `"main"` (and a new `"types"` field) to target the CommonJS build by default. We'll then copy the `"scripts"` suggested by snyk for now, as they seem reasonable. One thing it appears the snyk blog glossed over is actually running `npm install typescript --save-dev` to install TypeScript as a `"devDependencies"`, so we'll do that now. If we got to this stage we should be able to now `npm run build` (or our preferred `make build` which runs `npm pack` which runs `npm run prepack` which runs `npm run build`).

JavaScript still feels alien to set up compared to the other languages, that it's been a few months hiatus since I started on this. Coming back to it to continue on it, the next step in the snyk blog we were following is to add a testing framework. I have previously made changes to `mocha` tests without a greater context for it, but `mocha` as a test runner, `chai` as an assertions library, and `ts-node` to facilitate their operation on TypeScript files rather than plain JavaScript. To acquire these three we'll run `npm i -D mocha @types/mocha chai @types/chai ts-node` to install as developer dependencies. We've also got to include a `~/.mocharc.json` to instruct `mocha` how to run, and a `~/tests/index.spec.ts` to provide the tests to run.
