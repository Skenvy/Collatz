# Devlog
This is the start of the development of the [Go](https://go.dev/) package [(also see opensource.google)](https://cs.opensource.google/go/go). As go is a spec and not an implementation, it's worth quickly mentioning that locally this will be tested with `golang-go`, not `gccgo-go`. So after a quick `sudo apt install golang-go`, `go version` tells us we are on `go version go1.13.8 linux/amd64`, which is _already past EOL_ apparently. We'll also grab [the VS Code Go extension](https://marketplace.visualstudio.com/items?itemName=golang.Go).

[Get Started](https://go.dev/learn/) provides both [Documentation](https://go.dev/doc/) and [Create a Module](https://go.dev/doc/tutorial/create-module). The [pkg](https://pkg.go.dev/) index helpfully suggests some recommended examples of packages to search for, one being "unmarshal"; the top package for which is [sigs.k8s.io/yaml](https://pkg.go.dev/sigs.k8s.io/yaml), which comes from [this repo](https://github.com/kubernetes-sigs/yaml), an async fork of [this other repo](https://github.com/ghodss/yaml).

We'll use [actions/setup-go@v3](https://github.com/marketplace/actions/setup-go-environment), and we'll bookmark [goreleaser/goreleaser-action@v3](https://github.com/marketplace/actions/goreleaser-action) | [goreleaser](https://goreleaser.com/) for later. We can start the package by following the [Create a Module](https://go.dev/doc/tutorial/create-module) linked earlier and using the [go-mod-init](https://go.dev/ref/mod#go-mod-init) | [module-path](https://go.dev/ref/mod#module-path) to run `go mod init github.com/Skenvy/Collatz/go`, which creates an adjacent [go.mod file](https://go.dev/doc/modules/gomod-ref) with two lines; `module github.com/Skenvy/Collatz/go` and `go 1.13`.

It's immediately evident a few steps into the tutorial that go isn't a kind language, at least, not in terms of how obvious it is what it expects or requires. The primary units of code consumed are "packages", but packages must be contained in modules, and modules are what are released, not the individual pacakges independent of a module. The tutorial suggests having two modules in two adjacent folders, each containing a single package, so that one of them can contain a "main" package, as all files the same directory must be of the same package. But the pages on publishing make it appear as though any visible module will be published passively? Some more reading on this; [Using Go Modules](https://go.dev/blog/using-go-modules), [How to Write Go Code](https://go.dev/doc/code), [Developing and publishing modules](https://go.dev/doc/modules/developing), [Module release and versioning workflow](https://go.dev/doc/modules/release-workflow), [Publishing a module](https://go.dev/doc/modules/publishing), [Module version numbering](https://go.dev/doc/modules/version-numbers), and [Managing module source](https://go.dev/doc/modules/managing-source). I'd like to be able to "run" it as an executable parallel to the non-executable package that'd be published, i.e. publish a package "collatz" and have an executable with the same name, which must exist as a `package main`, so this will need some further evaluation. Also relevant for later could be the [Go Module Mirror, Index, and Checksum Database](https://proxy.golang.org/). After a little bit more reading, it appears that what might seem intuitive is supposedly true, that the go package indexing ignores anything that is `package main` by default, so there's no need to consider how to manually prevent it being indexed.

It doesn't seem easy to locate any mention of being able to list the version of the package as a file contents of the package, as the version is set not by file contents but the tagging of the commit, so there's "no need" to record it anywhere until it's been committed and tagged, at which point the tag obviously becomes the record. But the workflow design that we've used for the previous languages, and one I'd like to continue with, relies on the presence of a file that records the version it expects to publish, so let's just make one in the same `go.*` format as the other metadata files and create a `go.ver` (temptingly close to calling it `go.pher` but that seems a little too cheeky). We'll just record the package number in `go.ver` and read the file when doing the release step. The 'publishing steps' of the 'Publishing a module' page mention running `go mod tidy`. I'd like a dry-run option for it. But this appears to be an issue that's been requested for a long time; ["cmd/go: add mod tidy -check"](https://github.com/golang/go/issues/27005). So we'll need to figure out an alternative way of doing this. There is a "verbose" flag, although the output is written to stderr, so we can use `$(go mod tidy -v 2>&1)` to capture the results of it.
