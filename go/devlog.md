# Devlog
This is the start of the development of the [Go](https://go.dev/) package [(also see opensource.google)](https://cs.opensource.google/go/go). As go is a spec and not an implementation, it's worth quickly mentioning that locally this will be tested with `golang-go`, not `gccgo-go`. So after a quick `sudo apt install golang-go`, `go version` tells us we are on `go version go1.13.8 linux/amd64`, which is _already past EOL_ apparently. We'll also grab [the VS Code Go extension](https://marketplace.visualstudio.com/items?itemName=golang.Go). It's also worth mentioning, after having written the rest of this, that go has been more a process of unlearning what features to expect, although I may complain about some aspects of it, I had fun learning it none the less and definitely recognise it is a powerful language.

[Get Started](https://go.dev/learn/) provides both [Documentation](https://go.dev/doc/) and [Create a Module](https://go.dev/doc/tutorial/create-module). The [pkg](https://pkg.go.dev/) index helpfully suggests some recommended examples of packages to search for, one being "unmarshal"; the top package for which is [sigs.k8s.io/yaml](https://pkg.go.dev/sigs.k8s.io/yaml), which comes from [this repo](https://github.com/kubernetes-sigs/yaml), an async fork of [this other repo](https://github.com/ghodss/yaml).

We'll use [actions/setup-go@v3](https://github.com/marketplace/actions/setup-go-environment), and we'll bookmark [goreleaser/goreleaser-action@v3](https://github.com/marketplace/actions/goreleaser-action) | [goreleaser](https://goreleaser.com/) for later. We can start the package by following the [Create a Module](https://go.dev/doc/tutorial/create-module) linked earlier and using the [go-mod-init](https://go.dev/ref/mod#go-mod-init) | [module-path](https://go.dev/ref/mod#module-path) to run `go mod init github.com/Skenvy/Collatz/go`, which creates an adjacent [go.mod file](https://go.dev/doc/modules/gomod-ref) with two lines; `module github.com/Skenvy/Collatz/go` and `go 1.13`.

It's immediately evident a few steps into the tutorial that go isn't a kind language, at least, not in terms of how obvious it is what it expects or requires. The primary units of code consumed are "packages", but packages must be contained in modules, and modules are what are released, not the individual pacakges independent of a module. The tutorial suggests having two modules in two adjacent folders, each containing a single package, so that one of them can contain a "main" package, as all files the same directory must be of the same package. But the pages on publishing make it appear as though any visible module will be published passively? Some more reading on this; [Using Go Modules](https://go.dev/blog/using-go-modules), [How to Write Go Code](https://go.dev/doc/code), [Developing and publishing modules](https://go.dev/doc/modules/developing), [Module release and versioning workflow](https://go.dev/doc/modules/release-workflow), [Publishing a module](https://go.dev/doc/modules/publishing), [Module version numbering](https://go.dev/doc/modules/version-numbers), and [Managing module source](https://go.dev/doc/modules/managing-source). I'd like to be able to "run" it as an executable parallel to the non-executable package that'd be published, i.e. publish a package "collatz" and have an executable with the same name, which must exist as a `package main`, so this will need some further evaluation. Also relevant for later could be the [Go Module Mirror, Index, and Checksum Database](https://proxy.golang.org/). After a little bit more reading, it appears that what might seem intuitive is supposedly true, that the go package indexing ignores anything that is `package main` by default, so there's no need to consider how to manually prevent it being indexed.

It doesn't seem easy to locate any mention of being able to list the version of the package as a file contents of the package, as the version is set not by file contents but the tagging of the commit, so there's "no need" to record it anywhere until it's been committed and tagged, at which point the tag obviously becomes the record. But the workflow design that we've used for the previous languages, and one I'd like to continue with, relies on the presence of a file that records the version it expects to publish, so let's just make one in the same `go.*` format as the other metadata files and create a `go.ver` (temptingly close to calling it `go.pher` but that seems a little too cheeky). We'll just record the package number in `go.ver` and read the file when doing the release step. The 'publishing steps' of the 'Publishing a module' page mention running `go mod tidy`. I'd like a dry-run option for it. But this appears to be an issue that's been requested for a long time; ["cmd/go: add mod tidy -check"](https://github.com/golang/go/issues/27005). So we'll need to figure out an alternative way of doing this. There is a "verbose" flag, although the output is written to stderr, so we can use `$(go mod tidy -v 2>&1)` to capture the results of it. The [License policy](https://pkg.go.dev/license-policy) gives the impression that a static copy of the license must exist in the root of the go module, and a license covering a superset of that won't be accounted for.

Now that we're almost ready to try and publish the hello world example before actually writing the content of the package, what about generating documentation? Something like [GoDoc](https://go.dev/blog/godoc) (and how to write [comments](https://go.dev/doc/comment) for it)? The [godoc](https://pkg.go.dev/golang.org/x/tools/cmd/godoc) tool's latest version is `1.11`, so it seems to have already been deprecated, although it mentions it uses the [go doc](https://pkg.go.dev/go/doc)'s command [ToHTML](https://pkg.go.dev/go/doc#ToHTML). There's also [pkgsite](https://pkg.go.dev/golang.org/x/pkgsite/cmd/pkgsite)? It seems that while godoc was apparently deprecated at the end of `1.11`(?) that the use of `pkgsite` was never made a possibility out of the box, at least, for earlier versions of go. I found [a blog](https://mdaverde.com/posts/golang-local-docs/) that agrees with me, and it appears that while it's possible to install godoc, it's not possible to install pkgsite without updating to [`1.16+`](https://pkg.go.dev/embed?tab=versions). So while it seems there's the possibility to use pkgsite if I update, I'd rather use what's available, and godoc still builds for me on `1.13` and pkgsite doesn't. But even picking godoc, it has a few of its own problems like [godoc: corpus fstree is nil](https://bugs.launchpad.net/ubuntu/+source/golang-1.9/+bug/1743452). The error appears to come from [here](https://go.googlesource.com/tools/+/refs/heads/release-branch.go1.13/godoc/corpus.go). But it's also discussed [here](https://github.com/golang/go/issues/15049), with a follow up issue because that one was "old", [here](https://github.com/golang/go/issues/23445).

I honestly get the impression that, as is characteristic for a product developed by Google, it's a graveyard of closed stale issues for problems that were never addressed, for product features that were deprecated before being fully implemented and before any replacement existed. The pace at which it's released means the set-up to use a particular version changes quite a lot. I want to be able to generate the same sort of docs that will be hosted on the main pkg site in a gh-pages site, so I need to be able to generate the same sort of docs. Neither of the two possible ways of doing that work out of the box or with a simple invocation. And what I was trying earlier was failing because "GoDoc" was deprecated before and without "pkgSite" being set up to do the same sort of thing, i.e. because google doesn't consider it worth supporting, so it's up to any individual who wants to generate / host their own docs to hack it together.

I'm settling for now on a very hacky way of slapping together the MVP of docs, where none of the links work but it renders a single page. There's no go tool for pushing docs to a branch, so will have to put one together in the step instead of the usual `make deploy_docs`. A thanks to [this site](https://www.alexedwards.net/blog/serving-static-sites-with-go) for suggesting the [./docs/main.go](#TODO) file, to preview the generated docs before pushing. Once again we create an empty orphan branch;
1. `git checkout --orphan gh-pages-go`
1. `rm .git/index ; git clean -fdx`
1. `git commit -m "Initial empty orphan" --allow-empty`
1. `git push --set-upstream origin gh-pages-go`

After starting to write the actual code for this implementation, I've learned quite abruptly that Go does not support overloading, nor does it support optional parameters. It also took a debug warning from the IDE to mention that function's are only exported if they start with a capital. Python and Julia both supported optional arguments so there was no need for overloading. Java does have overloading. So this will be the first implementation that does not have either. As such, we're choosing here to split the function names as "Parameterised*" and "*" for the core functions we're adding. It also appears there's no in built assertion, but we can make one work with `reflect.DeepEqual`.

As for Go not having a certain feature, [this doc](https://go.dev/doc/faq#Why_doesnt_Go_have_feature_X) clarifies the intent, although it does seem egregious for them to have included in-built functions that do use overloading, like make/new, while denying overloading to everyone else on the assumption they'd "use it wrong", and while I was looking at the syntax for adding an enum, it occurred to me that all the "official" ways to do things are in blog posts from 2009-2011, which is for older versions that are no longer supported, so only some of the stuff in those blogs still works, and most common things don't have "official" ways of doing them anymore, only semi-official based on what's most recommended by the community (I can only assume many of them did not have newer "official solutions" as the answers on StackOverflow would certainly have simply been a suggestion to read them).

That being said though, I have to also recognise that this is the language that docker and kubernetes were written in, so **I'd be a mad man to deny its power**. I'll just have to adjust to the simultaneous lack of overloading and optional parameters. Which, to be fair to the oppotunity to learn, was the whole point of this project, to learn these language's paradigms, which I might whine about a bit, but will eventually get used to.

My main mistake was assuming that go would have a "syntax sugar" the same way that python does, so when I made the julia version, it was essentially the same as the python version, but the java version needed a rework to account for it being an OO language, not a functional one. I originally started out copying the python source into go and modifying it, but it became a hundred times easier to start modifying the java source instead, even though go isn't strictly OO, the design principles seem to be much more similar.

It's been much easier to reimplement super verbose java code into go than it was to implement python into go, primarily I think because there's a lot of magic to python in terms of functionality that's out of the box, that you've gotta be more verbose with in java. The process of modifying the python was that I had to keep finding the functionality go was _missing_ and finding out how to reimplement it. The process of modifying the java was that I was able to see what explicit steps I took in java, see if there's a simpler way of doing it in go, find out that it's 50/50 if it's easier or needs a new implementation and then do it. But the critical difference is that I wasn't discovering that functionality I was trying to use was missing, I was able to pre-emptively investigate if functionality that was already in the java code existed in go, so there were no surprises. The end result is go functions that look more similar to the python, but that feel like they utilise a type system more similar to java.
