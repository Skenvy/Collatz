# Devlog
This is the start of the development of the [Go](https://go.dev/) package. As go is a spec and not an implementation, it's worth quickly mentioning that locally this will be tested with `golang-go`, not `gccgo-go`. So after a quick `sudo apt install golang-go`, `go version` tells us we are on `go version go1.13.8 linux/amd64`, which is _already past EOL_ apparently. We'll also grab [the VS Code Go extension](https://marketplace.visualstudio.com/items?itemName=golang.Go).

[Get Started](https://go.dev/learn/) provides both [Documentation](https://go.dev/doc/) and [Create a Module](https://go.dev/doc/tutorial/create-module). The [pkg](https://pkg.go.dev/) index helpfully suggests some recommended examples of packages to search for, one being "unmarshal"; the top package for which is [sigs.k8s.io/yaml](https://pkg.go.dev/sigs.k8s.io/yaml), which comes from [this repo](https://github.com/kubernetes-sigs/yaml), an async fork of [this other repo](https://github.com/ghodss/yaml).

We'll use [actions/setup-go@v3](https://github.com/marketplace/actions/setup-go-environment), and we'll bookmark [goreleaser/goreleaser-action@v3](https://github.com/marketplace/actions/goreleaser-action) | [goreleaser](https://goreleaser.com/) for later. We can start the package by following the [Create a Module](https://go.dev/doc/tutorial/create-module) linked earlier and using the [go-mod-init](https://go.dev/ref/mod#go-mod-init) | [module-path](https://go.dev/ref/mod#module-path) to run `go mod init github.com/Skenvy/Collatz/go`, which creates an adjacent [go.mod file](https://go.dev/doc/modules/gomod-ref) with two lines; `module github.com/Skenvy/Collatz/go` and `go 1.13`.

It's immediately evident a few steps into the tutorial that go isn't a kind language, at least, not in terms of how obvious it is what it expects or requires. The primary units of code consumed are "packages", but packages must be contained in modules, and modules are what are released, not the individual pacakges independent of a module. The tutorial suggests having two modules in two adjacent folders, each containing a single package, so that one of them can contain a "main" package, as all files the same directory must be of the same package. But the pages on publishing make it appear as though any visible module will be published passively? Some more reading on this; [Using Go Modules](https://go.dev/blog/using-go-modules), [How to Write Go Code](https://go.dev/doc/code), [Developing and publishing modules](https://go.dev/doc/modules/developing), [Module release and versioning workflow](https://go.dev/doc/modules/release-workflow), and [Managing module source](https://go.dev/doc/modules/managing-source). I'd like to be able to "run" it as an executable parallel to the non-executable package that'd be published, i.e. publish a package "collatz" and have an executable with the same name, which must exist as a `package main`, so this will need some further evaluation.
