# Devlog
This will be my first foray into [Julia](https://julialang.org/), so first of all, lets get some links going;
* [Docs](https://docs.julialang.org/en/v1/) | [Download](https://julialang.org/downloads/) | [Package _manager_](https://pkgdocs.julialang.org/v1/) | [Environments](https://pkgdocs.julialang.org/v1/environments/)
* [Package Repository Primer](https://julialang.org/packages/) | [JuliaHub](https://juliahub.com/ui/Packages) | [JuliaPackages](https://juliapackages.com/packages)
* [CLI options](https://docs.julialang.org/en/v1/manual/command-line-options/)
* [_Creating Packages_](https://pkgdocs.julialang.org/v1/creating-packages/)
* [JuliaRegistries/General: **_Where_ to actually submit a package**](https://github.com/JuliaRegistries/General)
* [JuliaRegistries/Registrator: **_How_ to actually submit a package**](https://github.com/JuliaRegistries/Registrator.jl/)
* [An example package, beautifulalgorithms](https://juliapackages.com/packages/beautifulalgorithms). | [JuMP](https://github.com/jump-dev/JuMP.jl) | [Genie](https://github.com/GenieFramework/Genie.jl)
* [TagBot](https://discourse.julialang.org/t/ann-the-tagbot-github-app-is-deprecated-in-favour-of-the-tagbot-github-action/34344) | [PackageCompiler](https://github.com/JuliaLang/PackageCompiler.jl) | [DocumentationGenerator](https://github.com/JuliaDocs/DocumentationGenerator.jl) | [Compat](https://pkgdocs.julialang.org/v1/compatibility/)
* [Documenter](https://juliadocs.github.io/Documenter.jl/stable/man/guide/) | [Documentation style](https://docs.julialang.org/en/v1/manual/documentation/) | [Examples](https://juliadocs.github.io/Documenter.jl/stable/man/examples/) | [Documenter-hosting](https://juliadocs.github.io/Documenter.jl/stable/man/hosting/) | [Doctests](https://juliadocs.github.io/Documenter.jl/stable/man/doctests/)
#
Once [downloaded](https://julialang.org/downloads/), let's start with [the guide for creating a package](https://pkgdocs.julialang.org/v1/creating-packages/). The [guide here](https://pkgdocs.julialang.org/v1/creating-packages/) makes significant mention to the naming expected of a package. The name Collatz would appear wholly appropriate for a package that deals with only that! From the julia folder, `pkg> generate Collatz` does the trick (with pkg version 1.7). For some reason it didn't add my email to the `Project.toml`'s author list, so added manually. However, the name of the folder is of questionable consequence. It appears very heavily customary for julia packages to be singular entites in `X.jl` repos fot a project named `X`, although all guides I can find for it go through steps where a project in a folder `X` is created as a local git repository in `~/.julia/dev/X` and set to target some `X.jl` repo. I'm _assuming_ that when submitting the package, only the name in the `Project.toml` will matter, so rather than have the code in a subfolder, I've copied the contents created by the `pkg> generate Collatz` into the `~/julia/` directory of this repo. We'll have to wait and see I guess.
#
Some handy blogs ~ [this one](https://syl1.gitbook.io/julia-language-a-concise-tutorial/language-core/11-developing-julia-packages) | [oddly enough, a medium article](https://medium.com/coffee-in-a-klein-bottle/developing-your-julia-package-682c1d309507) | [and this one](https://blog.jcharistech.com/2021/09/27/how-to-develop-and-publish-julia-packages-for-beginners/).
#
I realise now after reading a lot of the above that while julia packages have genuine CI, the CD is only "semi" automatic (so not properly _continuous_) -- that is to say, there's github actions amongs the links above for testing and building on the package, and can be incorporated as CI, but the CD step does not yet exist, at least, not **_Out of the Box_**, and not as the recommended approach. The [Registrator](https://github.com/JuliaRegistries/Registrator.jl) linked above is the recommended way of submitting pacakges to [JuliaRegistries/General](https://github.com/JuliaRegistries/General), which requires [installing the app](https://github.com/apps/juliateam-registrator/installations/new) and commenting `@JuliaRegistrator register` on a commit/branch.
#
Thankfully, it appears there is a way to [target a subdirectory as "the package"](https://github.com/JuliaRegistries/Registrator.jl#registering-a-package-in-a-subdirectory) to search for a `Project.toml` instead of the repo root `~/`; for example `@JuliaRegistrator register subdir=path/to/my/package`. We also need to follow the guide to add auto docs from [Documenter](https://juliadocs.github.io/Documenter.jl/stable/man/guide/) (which looks like it came from [this thread](https://github.com/JuliaDocs/Documenter.jl/issues/1413)?). The JuMP package is a good example of heavy use of docs. A few different places with examples of docs have different scopes of interpretation for whether `docs/make.jl` should include the deploy or not, but I prefer the `julia --project=some/dir -E/e "commands; to; eval;"` syntax.
#
I took a small break from this to put out [julia-release](https://github.com/Skenvy/julia-release), my first github action, so that I could use it for [this project's julia-build workflow](https://github.com/Skenvy/Collatz/blob/main/.github/workflows/julia-build.yaml). With that added, we've also got to add the base [LICENSE](https://github.com/Skenvy/Collatz/blob/main/LICENSE) to this directory as well, as Julia packages are implicitly just references to a sub-tree of a repository, that requires the license to be checked in in the same directory, and won't accept a superset license. This _should_ be the same license as that in the repo root, [just duplicated here](https://github.com/Skenvy/Collatz/blob/main/julia/LICENSE). Although I'd prefer to initiate the project with a semver of 0.9.0, as a prerelease of 1.0.0 before cleaning it up and adding the proper docs, the registrator bot will comment/warn if the _first_ version of a package added to General is not one of either `1.0.0`, `0.1.0`, or `0.0.1`, so the last step is to clean it up (now that all the base tests work) and add docs. Registrator claims that _it_ automatically adds docs that are described in the `~/<julia>/docs` in the standard way, so I'll set them up, not sure how to verify 100% pre release, although will make good use of an extra `Project.toml` in `~/<julia>/docs/viewer` to run `using LiveServer; serve(dir="docs/build")` as part of the local docs test (shout out to [LiveServer](https://github.com/tlienart/LiveServer.jl)).
#
(The license file "here" linked above wont exist until this is merged again). It appears that it is recommended to host documentation built by Documenter on a github io page, which can be automated with a deploydocs step in the `~/docs/make.jl`, although the front page of a package on something like juliahub is a copy of the README. So there needs to be some inter-referentiality between the two.
#
The last snag it seems is [making Documenter happy about version tags](https://juliadocs.github.io/Documenter.jl/stable/man/hosting/#Documentation-Versions) that aren't what it's expecting. At the time of writing the top commit of [Documenter](https://github.com/JuliaDocs/Documenter.jl) is [cd49b078](https://github.com/JuliaDocs/Documenter.jl/commit/cd49b078a8ce6e1ff17f56d8b98f3f92e93b963f). Version [b90aa470](https://github.com/JuliaDocs/Documenter.jl/commit/b90aa4707c883ad715d084011cef39c9ba2501ca) of `./Documenter.jl/src/Documenter.jl` uses a `function deploydocs(` wherein the `deploy_subfolder` is decided by a `deploy_decision.subfolder` which comes from `deploy_decision = deploy_folder(deploy_config;`. Version [b6017acf](https://github.com/JuliaDocs/Documenter.jl/commit/b6017acfe17d321d498c5ee2dbb89898ea395d0c) of `./Documenter.jl/src/deployconfig.jl` contains multiple `function deploy_folder`, and we're looking for the one with `cfg::GitHubActions` as an argument.
The `subfolder` value we need to coalesce into a meaningful version tag is set in three places. To get it to be a tag value, we first need `build_type === :release`. The version releases are built on a push or dispatch, not a PR, so we just need `occursin(r"^refs\/tags\/(.*)$", cfg.github_ref)`. `cfg.github_ref` for `cfg::GitHubActions` is set via `github_ref = get(ENV, "GITHUB_REF", "") # "refs/heads/$(branchname)" for branch, "refs/tags/$(tagname)" for tag`.
Our whole workflow is initiated by a push with a ref to main. So for deploydocs to deploy a version tag when not initiated from a tag push, we'll have to frob the GITHUB_REF. For a proper CICD experience, a single push to main should be enough to successfully yield a full deployment if it passes all the checks, but having a tag pushed from a build process that uses a GITHUB_TOKEN wont initiate another workflow, and using a personal access token is a poor security choice. So to satisfy our CICD hopes and dreams without sacrificing security, frobbing the value of GITHUB_REF during the deploydocs step is the best choice.
Although this means that, with [a gh-pages auto merging workflow](https://github.com/Skenvy/Collatz/blob/main/.github/workflows/github-pages.yaml) that unambiguously uses `git merge --squash origin/${{ inputs.merge_from }} --allow-unrelated-histories -X theirs`, any push that triggers the ordinary [build process for julia](https://github.com/Skenvy/Collatz/blob/main/.github/workflows/julia-build.yaml), which is a push to main that changes `./julia/Project.toml`, will overwrite the versioned docs, regardless of if the `release-and-register` job in the workflow actually creates a new release or not. The `release-and-register` job is set up to ignore changes to the `./julia/Project.toml` that don't update the version. While we'd hope that idiomatically any change to `./julia/Project.toml` would imply a change to the version, it's not a guarantee, and poor form to rely on only that. To circumvent this, we can use [jobs.<job_id>.outputs](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idoutputs) to `if` the docs based on the output of the `release-and-register` job finding a new version, and then only use that value to frob the GITHUB_REF. Setting `env: GITHUB_REF: 'refs/tags/v${{ needs.release-and-register.outputs.new_version }}'` for the step that runs `make docs_deploy` should succeed at qualifying `occursin(r"^refs\/tags\/(.*)$", cfg.github_ref)`. We then need only confirm the behaviour of `function version_tag_strip_build(tag)` in `deployconfig.jl`, which begins with `m = match(Base.VERSION_REGEX, tag)` (notably, `Base.VERSION_REGEX` seems odd to be something in `Base`, and is also very unforgiving, but should accept the tag if it is a simple `vX.Y.Z`).
