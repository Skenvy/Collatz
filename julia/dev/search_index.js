var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Collatz.collatz_function\nCollatz.reverse_collatz_function\nCollatz.hailstone_sequence\nCollatz.stopping_time\nCollatz.tree_graph","category":"page"},{"location":"functions/#Collatz.collatz_function","page":"Functions","title":"Collatz.collatz_function","text":"collatz_function(n; P=2, a=3, b=1)\n\nReturns the output of a single application of a Collatz-esque function.\n\nArgs\n\nn::Integer: The value on which to perform the Collatz-esque function\n\nKwargs\n\nP::Integer=2: Modulus used to devide n, iff n is equivalent to (0 mod P).\na::Integer=3: Factor by which to multiply n.\nb::Integer=1: Value to add to the scaled value of n.\n\nExamples\n\njulia> collatz_function(5)\n16\n\njulia> collatz_function(14, P=7)\n2\n\njulia> collatz_function(15, P=7, a=5, b=3)\n78\n\n\n\n\n\n","category":"function"},{"location":"functions/#Collatz.reverse_collatz_function","page":"Functions","title":"Collatz.reverse_collatz_function","text":"reverse_collatz_function(n; P=2, a=3, b=1)\n\nReturns the output of a single application of a Collatz-esque reverse function.\n\nArgs\n\nn::Integer: The value on which to perform the reverse Collatz function\n\nKwargs\n\nP::Integer=2: Modulus used to devide n, iff n is equivalent to (0 mod P).\na::Integer=3: Factor by which to multiply n.\nb::Integer=1: Value to add to the scaled value of n.\n\nExamples\n\njulia> print(reverse_collatz_function(1))\n[2]\n\njulia> print(reverse_collatz_function(4))\n[1, 8]\n\njulia> print(reverse_collatz_function(3, P=-3, a=-2, b=-5))\n[-9, -4]\n\n\n\n\n\n","category":"function"},{"location":"functions/#Collatz.hailstone_sequence","page":"Functions","title":"Collatz.hailstone_sequence","text":"hailstone_sequence(initial_value; P=2, a=3, b=1, max_total_stopping_time=1000, total_stopping_time=true, verbose=true)\n\nReturns a list of successive values obtained by iterating a Collatz-esque function.\n\nUntil either 1 is reached, or the total amount of iterations exceeds maxtotalstoppingtime. Unless totalstopping_time is False, which will terminate the hailstone at the \"stopping time\" value, i.e. the first value less than the initial value. While the sequence has the capability to determine that it has encountered a cycle, the cycle from \"1\" wont be attempted or reported as part of a cycle, regardless of default or custom parameterisation, as \"1\" is considered a \"total stop\".\n\nArgs\n\ninitial_value::Integer: The value to begin the hailstone sequence from.\n\nKwargs\n\nP::Integer=2: Modulus used to devide n, iff n is equivalent to (0 mod P).\na::Integer=3: Factor by which to multiply n.\nb::Integer=1: Value to add to the scaled value of n.\nmax_total_stopping_time::Integer=1000: Maximum amount of times to iterate the   function, if 1 is not reached.\ntotal_stopping_time::Bool=true: Whether or not to execute until the \"total\"   stopping time (number of iterations to obtain 1) rather than the regular stopping   time (number of iterations to reach a value less than the initial value).\nverbose::Bool=true: If set to verbose, the hailstone sequence will include   control string sequences to provide information about how the sequence   terminated, whether by reaching a stopping time or entering a cycle.\n\nExamples\n\njulia> print(hailstone_sequence(16, verbose=false))\n[16, 8, 4, 2, 1]\n\njulia> print(hailstone_sequence(16))\nAny[16, 8, 4, 2, 1, Any[Collatz._CC.TOTAL_STOPPING_TIME, 4]]\n\njulia> print(hailstone_sequence(761, P=5, a=2, b=3, verbose=false))\n[761, 1525, 305, 61, 125, 25, 5, 1]\n\nExample cycle!\n\njulia> print(hailstone_sequence(-56))\nAny[-56, -28, Collatz._CC.CYCLE_INIT, Any[-14, -7, -20, -10, -5], Any[Collatz._CC.CYCLE_LENGTH, 5]]\n\njulia> print(hailstone_sequence(-56, verbose=false))\n[-56, -28, -14, -7, -20, -10, -5, -14]\n\n\n\n\n\n","category":"function"},{"location":"functions/#Collatz.stopping_time","page":"Functions","title":"Collatz.stopping_time","text":"stopping_time(initial_value; P=2, a=3, b=1, max_stopping_time=1000, total_stopping_time=false)\n\nReturns the stopping time, the amount of iterations required to reach a value less than the initial value, or nothing if maxstoppingtime is exceeded.\n\nAlternatively, if totalstoppingtime is True, then it will instead count the amount of iterations to reach 1. If the sequence does not stop, but instead ends in a cycle, the result will be infinity. If (P,a,b) are such that it is possible to get stuck on zero, the result will be the negative of what would otherwise be the \"total stopping time\" to reach 1, where 0 is considered a \"total stop\" that should not occur as it does form a cycle of length 1.\n\nArgs\n\ninitial_value::Integer: The value for which to find the stopping time.\n\nKwargs\n\nP::Integer=2: Modulus used to devide n, iff n is equivalent to (0 mod P).\na::Integer=3: Factor by which to multiply n.\nb::Integer=1: Value to add to the scaled value of n.\nmax_stopping_time::Integer=1000: Maximum amount of times to iterate the function, if the stopping   time is not reached. IF the maxstoppingtime is reached, the function will return nothing.\ntotal_stopping_time::Bool=false: Whether or not to execute until the \"total\"   stopping time (number of iterations to obtain 1) rather than the regular   stopping time (number of iterations to reach a value less than the initial value).\n\nExamples\n\njulia> stopping_time(5)\n3\njulia> stopping_time(27)\n96\njulia> stopping_time(21, P=5, a=2, b=3, total_stopping_time=true)\nInf\n\n\n\n\n\n","category":"function"},{"location":"functions/#Collatz.tree_graph","page":"Functions","title":"Collatz.tree_graph","text":"tree_graph(initial_value, max_orbit_distance; P=2, a=3, b=1, __cycle_prevention=nothing)\n\nReturns nested dictionaries that model the directed tree graph up to a maximum nesting of maxorbitdistance, with the initial_value as the root.\n\nArgs\n\ninitial_value::Integer: The root value of the directed tree graph.\nmax_orbit_distance::Integer: Maximum amount of times to iterate the reverse   function. There is no natural termination to populating the tree graph, equivalent   to the termination of hailstone sequences or stopping time attempts, so this is not   an optional argument like maxstoppingtime / maxtotalstopping_time, as it is the   intended target of orbits to obtain, rather than a limit to avoid uncapped computation.\n\nKwargs\n\nP::Integer=2: Modulus used to devide n, iff n is equivalent to (0 mod P).\na::Integer=3: Factor by which to multiply n.\nb::Integer=1: Value to add to the scaled value of n.\n\nInternal Kwargs\n\n__cycle_prevention::Union{Set{Integer},Nothing}=nothing: Used to prevent cycles   from precipitatingby keeping track of all values added across previous nest depths.\n\nExamples\n\njulia> print(tree_graph(1, 3))\nDict{Int64, Dict{Any, Any}}(1 => Dict(2 => Dict{Any, Any}(4 => Dict{Any, Any}(Collatz._CC.CYCLE_INIT => 1, 8 => Dict{Any, Any}()))))\n\njulia> print(tree_graph(4, 3))\nDict{Int64, Dict{Any, Any}}(4 => Dict(8 => Dict{Any, Any}(16 => Dict{Any, Any}(5 => Dict{Any, Any}(), 32 => Dict{Any, Any}())), 1 => Dict{Any, Any}(2 => Dict{Any, Any}(Collatz._CC.CYCLE_INIT => 4))))\n\n\n\n\n\n","category":"function"},{"location":"internal_modules/#Internal-Modules","page":"Internal Modules","title":"Internal Modules","text":"","category":"section"},{"location":"internal_modules/","page":"Internal Modules","title":"Internal Modules","text":"Collatz._CC\nCollatz._ErrMsg","category":"page"},{"location":"internal_modules/#Collatz._CC","page":"Internal Modules","title":"Collatz._CC","text":"Cycle Control: Descriptive flags to indicate when some event occurs in the hailstone sequences, when set to verbose, or stopping time check. A module used to wrap an enum to reference the values as _CC.ABC rather than ABC::CC\n\nExamples\n\njulia> string(_CC.STOPPING_TIME)\n\"STOPPING_TIME\"\njulia> string(_CC.TOTAL_STOPPING_TIME)\n\"TOTAL_STOPPING_TIME\"\njulia> string(_CC.CYCLE_INIT)\n\"CYCLE_INIT\"\njulia> string(_CC.CYCLE_LENGTH)\n\"CYCLE_LENGTH\"\njulia> string(_CC.MAX_STOP_OOB)\n\"MAX_STOP_OOB\"\njulia> string(_CC.ZERO_STOP)\n\"ZERO_STOP\"\n\n\n\n\n\n","category":"module"},{"location":"internal_modules/#Collatz._ErrMsg","page":"Internal Modules","title":"Collatz._ErrMsg","text":"Error message constant.\n\n\n\n\n\n","category":"module"},{"location":"internal_functions/#Internal-Functions","page":"Internal Functions","title":"Internal Functions","text":"","category":"section"},{"location":"internal_functions/","page":"Internal Functions","title":"Internal Functions","text":"Collatz.__assert_sane_parameterisation\nCollatz.__initial_value_outside_verified_range\nCollatz.__stopping_time_terminus","category":"page"},{"location":"internal_functions/#Collatz.__assert_sane_parameterisation","page":"Internal Functions","title":"Collatz.__assert_sane_parameterisation","text":"__assert_sane_parameterisation(P, a, b)\n\nHandles the sanity check for the parameterisation (P,a,b) required by both the function and reverse function.\n\nArgs\n\nP::Integer: Modulus used to devide n, iff n is equivalent to (0 mod P).\na::Integer: Factor by which to multiply n.\nb::Integer: Value to add to the scaled value of n.\n\n\n\n\n\n","category":"function"},{"location":"internal_functions/#Collatz.__initial_value_outside_verified_range","page":"Internal Functions","title":"Collatz.__initial_value_outside_verified_range","text":"__initial_value_outside_verified_range(x)\n\nChecks if the initial value is greater than __VERIFIEDMAXIMUM or less than __VERIFIEDMINIMUM. Only intended for the default parameterisation.\n\nArgs\n\nx::Integer: The initial value to check if it is within range or not.\n\n\n\n\n\n","category":"function"},{"location":"internal_functions/#Collatz.__stopping_time_terminus","page":"Internal Functions","title":"Collatz.__stopping_time_terminus","text":"__stopping_time_terminus(n, total_stop)\n\nProvides the appropriate lambda to use to check if iterations on an initial value have reached either the stopping time, or total stopping time.\n\nArgs\n\nn::Integer: The initial value to confirm against a stopping time check.\ntotal_stop::Bool: If false, the lambda will confirm that iterations   of n have reached the oriented stopping time to reach a value closer   to 0. If true, the lambda will simply check equality to 1.\n\n\n\n\n\n","category":"function"},{"location":"constants/#Constants","page":"Constants","title":"Constants","text":"","category":"section"},{"location":"constants/","page":"Constants","title":"Constants","text":"Collatz._KNOWN_CYCLES\nCollatz.__VERIFIED_MAXIMUM\nCollatz.__VERIFIED_MINIMUM","category":"page"},{"location":"constants/#Collatz._KNOWN_CYCLES","page":"Constants","title":"Collatz._KNOWN_CYCLES","text":"The four known cycles (besides 0->0), for the default parameterisation.\n\n\n\n\n\n","category":"constant"},{"location":"constants/#Collatz.__VERIFIED_MAXIMUM","page":"Constants","title":"Collatz.__VERIFIED_MAXIMUM","text":"The value up to which has been proven numerically, for the default parameterisation.\n\n\n\n\n\n","category":"constant"},{"location":"constants/#Collatz.__VERIFIED_MINIMUM","page":"Constants","title":"Collatz.__VERIFIED_MINIMUM","text":"The value down to which has been proven numerically, for the default parameterisation.\n\n\n\n\n\n","category":"constant"},{"location":"","page":"Introduction","title":"Introduction","text":"# TODO: Add a logo ~ of the collatz coral\n# https://juliadocs.github.io/Documenter.jl/stable/man/guide/#Adding-a-logo-or-icon","category":"page"},{"location":"#Collatz","page":"Introduction","title":"Collatz","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"# Without ordering the files in the Pages list below, they all get alphabetically\n# sorted, which is more gross than just manually adding each file to this list.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"index.md\", \"functions.md\", \"constants.md\", \"internal_functions.md\", \"internal_modules.md\"]\nDepth = 2","category":"page"},{"location":"#Top-level-Module","page":"Introduction","title":"Top level Module","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Collatz.Collatz","category":"page"},{"location":"#Collatz.Collatz","page":"Introduction","title":"Collatz.Collatz","text":"Provides the basic functionality to interact with the Collatz conjecture. The parameterisation uses the same (P,a,b) notation as Conway's generalisations. Besides the function and reverse function, there is also functionality to retrieve the hailstone sequence, the \"stopping time\"/\"total stopping time\", or tree-graph.\n\nExamples\n\njulia> import Pkg; Pkg.add(\"Collatz\"); using Collatz\n\n\n\n\n\n","category":"module"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
